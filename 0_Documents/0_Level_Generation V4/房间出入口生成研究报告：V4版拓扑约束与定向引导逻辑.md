# 房间出入口生成研究报告：V4版拓扑约束与定向引导逻辑

## 1. 执行摘要 (Executive Summary)

在PCG（程序化内容生成）系统中，出入口的定位与引导逻辑直接决定了关卡的"心流"与"可玩性"。本报告针对V4方案在4x4宏观网格下的特定需求——即顶行随机起始、水平向出入口约束、以及起终点逻辑标记——提供深度的架构设计与算法实现细节。

核心逻辑在于：通过在 `RoomNode` 元数据中引入状态标记位，并结合约束性的出入口选择算法，确保玩家从顶层侧方切入关卡，穿越随机路径后，从底层或终端房间的侧方撤离。本方案将利用 `UniTask` 处理拓扑计算，并通过 `ScriptableObject` 插件化装载不同的约束规则。

## 2. 宏观约束：4x4网格出入口定位逻辑

### 2.1 起始房间选择规则

根据需求，起始房间（Entrance Room）必须位于 4x4 网格的顶端排（Y=0 或 Y=3，取决于坐标系定义）。

**算法步进：**

1. 随机索引 `X ∈ [0, 3]`
2. 固定索引 `Y=0`（假设顶行为0）
3. 实例化 `RoomNode` 并标记 `RoomTag.Start`

### 2.2 出入口侧向约束 (Side-Only Constraint)

为了强制形成水平方向的切入感，排除垂直方向（Top/Bottom）的逻辑门：

- **入口方位**：在 `StartNode` 中，随机选择 `DoorDirection.Left` 或 `DoorDirection.Right` 作为"关卡切入点"
- **出口方位**：在 `EndNode` 中，同样随机选择 `DoorDirection.Left` 或 `DoorDirection.Right` 作为"关卡完成点"
- **技术实现**：在微观地形生成阶段，`TilemapVisualizer` 必须读取此方向标记，在对应墙壁中间挖掘出入口，并忽略该房间在该方向上的普通连接

## 3. 算法增强：带标记位的醉汉随机游走

### 3.1 房间节点元数据扩展

为了支持 AI 编程 IDE 理解，必须定义明确的数据结构：

```csharp
public enum RoomTag
{
    Normal = 0,
    Start = 1,  // 用于生成出生点
    End = 2     // 用于生成通关点
}

public enum LevelDoorType
{
    None = 0,
    LevelEntrance = 1, // 玩家进入关卡的门
    LevelExit = 2      // 玩家离开关卡的门
}

public class RoomNode
{
    public Vector2Int GridPos;
    public RoomTag Tag;
    public LevelDoorType DoorType;
    public WallDirection RestrictedDoorSide; // 仅限 Left 或 Right

    // 连接信息，用于连接 4x4 内部的其他房间
    public List<Vector2Int> ConnectedNeighbors = new List<Vector2Int>();
}
```

### 3.2 游走流程与终点识别

**初始化：**

- 在网格 `(X_rand, 0)` 放置第一个 Walker，标记为 `RoomTag.Start`

**游走权重：**

- 向下方（`Y+`）和侧方（`X±`）给予更高权重，强制路径向网格深处延伸

**终点判定：**

- **方案 A (步数阈值)**：当游走步数达到最大值（如 10 步）时，最后一个单元格标记为 `RoomTag.End`
- **方案 B (最远距离)**：游走结束后，计算所有节点与 `StartNode` 的最短路径距离，选取距离值最大的节点作为 `EndNode`

**后处理约束：**

- 为 `StartNode` 随机分配 `RestrictedDoorSide`（Left/Right），标记 `LevelEntrance`
- 为 `EndNode` 随机分配 `RestrictedDoorSide`（Left/Right），标记 `LevelExit`

## 4. 关键代码功能分析：起终点逻辑实现

以下是为 AI IDE 准备的核心逻辑骨架，展示了如何在异步管线中嵌入出入口约束。

### 4.1 拓扑生成逻辑 (Macro Layer)

```csharp
public class ConstrainedLayoutRule : IGeneratorRule
{
    public int MaxRooms = 10;

    public async UniTask ExecuteAsync(DungeonContext context, CancellationToken token)
    {
        await UniTask.SwitchToThreadPool();

        // 1. 顶行随机选择起点
        Vector2Int startPos = new Vector2Int(context.RNG.Next(0, 4), 0);
        RoomNode startNode = CreateNode(startPos, RoomTag.Start, context);

        // 2. 侧向入口约束
        startNode.RestrictedDoorSide = context.RNG.Next(0, 2) == 0? WallDirection.Left : WallDirection.Right;
        startNode.DoorType = LevelDoorType.LevelEntrance;

        // 3. 醉汉游走逻辑...
        RoomNode lastNode = RunDrunkardWalk(startNode, context, token);

        // 4. 标记终点与侧向出口
        lastNode.Tag = RoomTag.End;
        lastNode.DoorType = LevelDoorType.LevelExit;
        lastNode.RestrictedDoorSide = context.RNG.Next(0, 2) == 0? WallDirection.Left : WallDirection.Right;

        await UniTask.SwitchToMainThread();
    }
}
```

### 4.2 微观实体放置逻辑 (Micro Layer)

此部分负责根据 `RoomTag` 放置特定的 Prefab。

```csharp
public class PointPlacementStrategy : TerrainStrategySO
{
    public GameObject PlayerSpawnPrefab;
    public GameObject ExitPortalPrefab;

    public override async UniTask ProcessAsync(DungeonContext context, RoomNode node)
    {
        // 仅在主线程进行 GameObject 操作
        await UniTask.SwitchToMainThread();

        if (node.Tag == RoomTag.Start)
        {
            // 在房间中心点生成出生点
            Object.Instantiate(PlayerSpawnPrefab, context.GridToWorld(node.GridPos), Quaternion.identity);
        }
        else if (node.Tag == RoomTag.End)
        {
            // 在房间中心点生成传送门
            Object.Instantiate(ExitPortalPrefab, context.GridToWorld(node.GridPos), Quaternion.identity);
        }
    }
}
```

## 5. 结论与 IDE 实施指南

### 5.1 实施要点

- **解耦标记与表现**：Drunkard's Walk 算法只负责将 Tag 写入 `RoomNode`，不涉及具体的渲染
- **物理校验**：侧向门（Left/Right）必须在 `TilemapVisualizer` 阶段强制清除对应的 `CompositeCollider2D` 区域，防止门被物理碰撞堵塞
- **路径保障**：必须在生成后运行 BFS 校验，确保 Start 到 End 之间没有任何墙壁完全阻断（即使游走失败也需要重试或修复路径）

### 5.2 交付 AI 的指令定义

> "请根据 `DungeonContext` 的 `RoomNodes` 列表，识别带有 `RoomTag.Start` 和 `RoomTag.End` 的房间。在 Start 房间的 `RestrictedDoorSide` 指定方向（左或右）生成一个入口门组件，并在房间中央生成 `PlayerSpawnPoint`。在 End 房间的 `RestrictedDoorSide` 指定方向生成一个出口门组件，并在中央生成 `LevelClearTrigger`。所有操作必须通过 `UniTask` 确保在渲染周期内平滑执行。"
