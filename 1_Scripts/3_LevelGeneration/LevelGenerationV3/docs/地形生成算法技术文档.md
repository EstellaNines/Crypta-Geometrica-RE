# 地形生成算法技术文档

## 一、算法概述

本文档总结了CRYPTA GEOMETRICA RE项目中使用的所有地形生成算法，包括关键路径生成、洞穴填充、平台系统和出生点计算等核心算法。

---

## 二、关键路径生成算法

### 2.1 醉汉游走算法 (Drunkard's Walk)

**算法类型**: 随机游走算法  
**用途**: 生成关卡的主要通行路径，确保100%可通关性  
**灵感来源**: Spelunky关卡生成系统

#### 算法原理

醉汉游走算法模拟一个醉汉的随机行走轨迹，通过在网格中随机移动来生成连通路径。

#### 实现步骤

```
1. 初始化
   - 从顶排(y=0)随机选择起点
   - 创建空路径列表

2. 每层循环 (row = 0 to GridHeight-1)
   a. 水平游走阶段:
      - 随机选择方向 (左=-1, 右=1)
      - 随机选择步数 (1-3步)
      - 执行水平移动
      - 遇到边界则反向
   
   b. 垂直移动阶段:
      - 向下移动一格 (y+1)
      - 添加到路径列表
   
   c. 连接记录:
      - 记录房间之间的连接方向
      - 标记为关键路径

3. 路径标记
   - 起点房间标记为 Start
   - 终点房间标记为 Exit
   - 倒数第二个房间标记为 Boss
```

#### 伪代码

```python
def drunkard_walk(grid_width, grid_height):
    # 初始化
    start_x = random(0, grid_width)
    current = (start_x, 0)
    path = [current]
    
    # 每层循环
    for row in range(grid_height):
        # 水平游走
        direction = random_choice([-1, 1])
        steps = random(1, 4)
        
        for step in range(steps):
            next_x = current.x + direction
            
            # 边界检查
            if next_x < 0 or next_x >= grid_width:
                direction = -direction
                next_x = current.x + direction
            
            # 添加到路径
            next = (next_x, current.y)
            path.append(next)
            
            # 记录连接
            add_connection(current, next)
            current = next
        
        # 向下移动
        if row < grid_height - 1:
            next = (current.x, current.y + 1)
            path.append(next)
            add_connection(current, next)
            current = next
    
    return path
```

#### 关键参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 水平步数范围 | 1-3 | 每层水平移动的步数 |
| 网格尺寸 | 4×4 | 房间网格大小 |
| 反向概率 | 100% | 遇到边界必定反向 |

#### 优点
- 简单高效，计算复杂度 O(n)
- 保证路径连通性
- 生成自然的曲折路径
- 易于控制和调试

#### 缺点
- 路径可能过于简单
- 缺乏分支结构
- 难以生成复杂布局

---

## 三、洞穴地形生成算法

### 3.1 高斯堆积造山法 (Gaussian Accumulation)

**算法类型**: 概率场生成算法  
**用途**: 生成自然的洞穴地形填充  
**创新点**: 结合重力堆积和水平聚拢的概率梯度场

#### 算法原理

通过构建多维概率梯度场，模拟真实世界中的重力堆积和侵蚀效果，生成具有自然形态的洞穴地形。

#### 概率梯度场公式

```
最终概率 = 基础密度 × 边缘因子 + 重力堆积 + 水平聚拢 + 石笋注入

其中:
- 基础密度 = FillDensity (0.5)
- 边缘因子 = 1.5 (边缘6格内) 或 1.0 (其他区域)
- 重力堆积 = (1.0 - heightRatio) × 0.35
- 水平聚拢 = (1.0 - distToCenter) × 0.25
- 石笋注入 = 2-3根随机高度石笋
```

#### 实现步骤

```
1. 初始化洞穴数组
   cave[width, height] = false

2. 概率场生成
   for each position (x, y):
       a. 计算边缘因子
          distToEdge = min(x, y, width-x, height-y)
          edgeFactor = 1.5 if distToEdge < 6 else 1.0
       
       b. 计算重力堆积
          heightRatio = y / height
          gravityBonus = (1.0 - heightRatio) × 0.35
       
       c. 计算水平聚拢
          centerX = width / 2
          distToCenter = abs(x - centerX) / centerX
          centerBonus = (1.0 - distToCenter) × 0.25
       
       d. 计算最终概率
          probability = FillDensity × edgeFactor + gravityBonus + centerBonus
       
       e. 随机生成
          cave[x, y] = random() < probability

3. 石笋注入
   for i in range(2, 4):  # 2-3根石笋
       sx = random(width × 0.2, width × 0.8)
       maxHeight = random(height × 0.4, height × 0.7)
       thickness = random(1, 3)
       
       for dy in range(maxHeight):
           for dx in range(-thickness, thickness+1):
               cave[sx+dx, dy] = true

4. 细胞自动机平滑
   for iteration in range(SmoothIterations + 3):
       cave = smooth_cave(cave)
```

#### 伪代码

```python
def gaussian_accumulation(width, height, fill_density):
    cave = [[False] * height for _ in range(width)]
    
    # 概率场生成
    for y in range(height):
        for x in range(width):
            # 边缘因子
            dist_to_edge = min(x, y, width-1-x, height-1-y)
            edge_factor = 1.5 if dist_to_edge < 6 else 1.0
            
            # 重力堆积
            height_ratio = y / height
            gravity_bonus = (1.0 - height_ratio) * 0.35
            
            # 水平聚拢
            center_x = width / 2
            dist_to_center = abs(x - center_x) / center_x
            center_bonus = (1.0 - dist_to_center) * 0.25
            
            # 最终概率
            probability = fill_density * edge_factor + gravity_bonus + center_bonus
            cave[x][y] = random() < probability
    
    # 石笋注入
    for i in range(random(2, 4)):
        sx = random(width * 0.2, width * 0.8)
        max_height = random(height * 0.4, height * 0.7)
        thickness = random(1, 3)
        
        for dy in range(max_height):
            for dx in range(-thickness, thickness+1):
                if 0 <= sx+dx < width and dy < height:
                    cave[sx+dx][dy] = True
    
    # 平滑
    for _ in range(6):
        cave = smooth_cave(cave, width, height)
    
    return cave
```

#### 关键参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 基础密度 | 0.5 | 填充概率基准值 |
| 边缘因子 | 1.5 | 边缘区域概率增强 |
| 重力系数 | 0.35 | 垂直梯度强度 |
| 聚拢系数 | 0.25 | 水平梯度强度 |
| 石笋数量 | 2-3 | 随机石笋数量 |
| 平滑次数 | 6 | 细胞自动机迭代次数 |

#### 优点
- 生成自然的有机形态
- 底部密集，顶部稀疏，符合真实洞穴特征
- 石笋增加视觉多样性
- 可控性强，参数调整灵活

#### 缺点
- 计算复杂度较高 O(w×h×iterations)
- 需要多次平滑才能达到理想效果
- 参数调优需要经验

---

### 3.2 细胞自动机平滑算法 (Cellular Automata)

**算法类型**: 细胞自动机  
**用途**: 平滑洞穴边缘，创建有机形状  
**经典应用**: Minecraft洞穴生成、Terraria地形生成

#### 算法原理

基于邻居数量规则，迭代更新每个单元格的状态，使地形边缘更加平滑自然。

#### 规则定义

```
邻居数 ≥ 4: 变为墙壁 (true)
邻居数 < 4: 变为空气 (false)
邻居数 = 4: 保持不变
```

#### 实现步骤

```
1. 初始化新数组
   new_cave[width, height] = false

2. 遍历每个单元格
   for y in range(height):
       for x in range(width):
           a. 统计邻居数量
              neighbors = count_neighbors(cave, x, y)
           
           b. 应用规则
              if neighbors >= 4:
                  new_cave[x, y] = true
              else:
                  new_cave[x, y] = false

3. 返回新数组
   return new_cave
```

#### 邻居统计算法

```python
def count_neighbors(cave, x, y, width, height):
    count = 0
    
    # 检查8个方向
    for dy in range(-1, 2):
        for dx in range(-1, 2):
            if dx == 0 and dy == 0:
                continue  # 跳过自己
            
            nx = x + dx
            ny = y + dy
            
            # 边界算作墙壁
            if nx < 0 or nx >= width or ny < 0 or ny >= height:
                count += 1
            elif cave[nx][ny]:
                count += 1
    
    return count
```

#### 迭代效果

| 迭代次数 | 效果 |
|----------|------|
| 0 | 原始噪声，边缘锯齿 |
| 1-2 | 开始平滑，仍有小孔洞 |
| 3-4 | 较为平滑，形状稳定 |
| 5-6 | 非常平滑，有机形态 |
| 7+ | 过度平滑，细节丢失 |

#### 优点
- 算法简单，易于实现
- 生成自然的有机形态
- 可控性强，迭代次数可调
- 计算效率高 O(w×h)

#### 缺点
- 过度迭代会丢失细节
- 可能产生孤立区域
- 需要配合其他算法使用

---

## 四、平台生成算法

### 4.1 全局垂锚连接法 (Global Vertical Anchoring)

**算法类型**: 迭代修复算法  
**用途**: 确保所有平台可达，解决断层问题  
**创新点**: 全局扫描 + 局部修复 + 禁飞区约束

#### 算法原理

通过全局扫描检测所有平台的可达性，对于无法到达的平台，在其下方生成中继平台，形成阶梯式连接。

#### 实现步骤

```
1. 初始化
   maxIterations = 10
   iteration = 0
   totalAnchorsPlaced = 0

2. 迭代修复循环
   while iteration < maxIterations:
       a. 获取所有平台聚类
          clusters = get_platform_clusters()
       
       b. 按Y从高到低排序
          clusters.sort(key=lambda c: c.Y, reverse=True)
       
       c. 遍历每个平台聚类
          for cluster in clusters:
              i. 跳过地面附近平台
              ii. 禁飞区检查
              iii. 向下射线检测
              iv. 水平可达性检查
              v. 生成中继平台（如需要）
       
       d. 检查是否有新平台生成
          if no new platforms:
              break
       
       e. 迭代计数
          iteration += 1

3. 返回结果
   return totalAnchorsPlaced
```

#### 核心子算法

**1. 平台聚类算法**
```python
def get_platform_clusters(tilemap, bounds):
    clusters = []
    visited = set()
    
    for y in range(bounds.height):
        current_cluster = None
        
        for x in range(bounds.width):
            pos = (x, y)
            
            if has_platform(pos) and pos not in visited:
                visited.add(pos)
                
                # 检查可站立性
                if not is_standable(pos):
                    continue
                
                # 创建或扩展聚类
                if current_cluster is None or current_cluster.Y != y:
                    current_cluster = PlatformCluster(Y=y, MinX=x, MaxX=x)
                    clusters.append(current_cluster)
                else:
                    current_cluster.MaxX = x
                
                current_cluster.Tiles.append(pos)
    
    return clusters
```

**2. 向下射线检测**
```python
def raycast_down(from_pos, tilemap, max_distance):
    for dy in range(1, max_distance+1):
        below = (from_pos.x, from_pos.y - dy)
        
        if has_tile(tilemap, below):
            return dy  # 返回距离
    
    return max_distance  # 未找到
```

**3. 水平可达性检查**
```python
def check_horizontal_path(cluster, tilemap, safe_height, max_check):
    # 检查左侧
    for dx in range(1, max_check+1):
        check_x = cluster.MinX - dx
        
        for dy in range(0, safe_height+1):
            pos = (check_x, cluster.Y - dy)
            
            if has_tile(tilemap, pos):
                above = (check_x, cluster.Y - dy + 1)
                if not has_tile(tilemap, above):
                    return True  # 左侧有路径
    
    # 检查右侧（同理）
    # ...
    
    return False  # 无水平路径
```

#### 约束条件

| 约束 | 值 | 说明 |
|------|-----|------|
| 安全高度 | 4格 | 玩家可跳跃高度 |
| 禁飞区半径 | 10格 | 出入口附近不生成平台 |
| 最大迭代次数 | 10次 | 防止无限循环 |
| 中继平台宽度 | 3格 | 足够玩家站立 |
| 水平检测范围 | 8格 | 左右扫描距离 |

#### 优点
- 保证100%平台可达性
- 自动修复断层问题
- 支持复杂地形
- 禁飞区避免破坏关键区域

#### 缺点
- 可能生成过多平台
- 迭代次数影响性能
- 需要精细调参

---

## 五、出生点计算算法

### 5.1 BFS最远距离算法 (BFS Farthest Point)

**算法类型**: 广度优先搜索 (BFS)  
**用途**: 计算距离参考门最远的有效可站立位置  
**优势**: 保证找到真正的最远点，而非局部最优

#### 算法原理

使用BFS洪水填充算法构建距离场，然后在距离最远的候选点中筛选出第一个满足物理约束的可站立位置。

#### 实现步骤

```
1. 初始化
   distance_map = {}
   queue = Queue()
   
   # 找到起点附近的空气位置
   actual_start = find_nearest_air(start_pos)
   queue.enqueue(actual_start)
   distance_map[actual_start] = 0

2. BFS洪水填充
   while queue not empty:
       current = queue.dequeue()
       current_distance = distance_map[current]
       
       # 检查四个方向
       for direction in [Up, Down, Left, Right]:
           neighbor = current + direction
           
           # 验证邻居有效性
           if is_valid_tile(neighbor):
               distance_map[neighbor] = current_distance + 1
               queue.enqueue(neighbor)

3. 候选点筛选
   candidates = distance_map.sort_by_distance(descending=True).take(10)

4. 物理验证
   for candidate in candidates:
       if is_standable_position(candidate):
           return candidate

5. 降级方案
   return bounds_center_fallback()
```

#### 可站立性检测算法

```python
def is_standable_position(pos, ground_layer, platform_layer):
    # 1. 脚下检测
    below = (pos.x, pos.y - 1)
    has_floor = has_tile(ground_layer, below) or has_tile(platform_layer, below)
    if not has_floor:
        return False
    
    # 2. 当前位置检测
    if has_tile(ground_layer, pos):
        return False
    
    # 3. 跳跃净空检测（头顶3格）
    for dy in range(1, 4):
        check_pos = (pos.x, pos.y + dy)
        if has_tile(ground_layer, check_pos) or has_tile(platform_layer, check_pos):
            return False
    
    # 4. 横向活动域检测
    left = (pos.x - 1, pos.y)
    right = (pos.x + 1, pos.y)
    left_clear = not has_tile(ground_layer, left)
    right_clear = not has_tile(ground_layer, right)
    
    if not left_clear and not right_clear:
        return False  # 左右都被堵死
    
    # 5. 垂直井检测
    if not left_clear or not right_clear:
        left_above = (pos.x - 1, pos.y + 1)
        right_above = (pos.x + 1, pos.y + 1)
        left_above_clear = not has_tile(ground_layer, left_above)
        right_above_clear = not has_tile(ground_layer, right_above)
        
        if (not left_clear and not right_above_clear) or \
           (not right_clear and not left_above_clear):
            return False  # 形成狭窄垂直通道
    
    return True
```

#### 关键参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 候选点数量 | 10 | 距离最远的前N个点 |
| 搜索半径 | 5格 | 寻找起点空气位置 |
| 跳跃净空 | 3格 | 头顶必须无阻挡 |
| 安全区尺寸 | 3×4格 | 出生点清理区域 |

#### 优点
- 保证找到真正的最远点
- 物理约束严格，避免卡墙
- 支持复杂地形
- 降级方案保证鲁棒性

#### 缺点
- BFS计算复杂度 O(n)
- 需要遍历整个搜索区域
- 候选点筛选可能耗时

---

## 六、算法性能分析

### 6.1 时间复杂度

| 算法 | 时间复杂度 | 说明 |
|------|------------|------|
| 醉汉游走 | O(n) | n为房间数量 |
| 高斯堆积造山 | O(w×h×k) | w×h为区域大小，k为迭代次数 |
| 细胞自动机 | O(w×h) | 单次迭代 |
| 垂锚连接 | O(m×n) | m为平台数量，n为迭代次数 |
| BFS最远距离 | O(w×h) | 搜索区域大小 |

### 6.2 空间复杂度

| 算法 | 空间复杂度 | 说明 |
|------|------------|------|
| 醉汉游走 | O(n) | 路径列表 |
| 高斯堆积造山 | O(w×h) | 洞穴数组 |
| 细胞自动机 | O(w×h) | 临时数组 |
| 垂锚连接 | O(m) | 平台聚类列表 |
| BFS最远距离 | O(w×h) | 距离场字典 |

### 6.3 优化建议

1. **使用Job System并行化**
   - 洞穴生成可并行处理每个网格
   - 细胞自动机可并行处理每个单元格

2. **使用Burst Compiler加速**
   - 数学密集型计算（概率场、邻居统计）
   - 数组遍历操作

3. **缓存优化**
   - 缓存距离场避免重复计算
   - 缓存平台聚类结果

4. **算法优化**
   - 使用HashSet避免重复访问
   - 提前终止条件减少迭代

---

## 七、算法对比

### 7.1 洞穴生成算法对比

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 高斯堆积造山 | 自然形态，可控性强 | 计算复杂 | 大型洞穴 |
| Perlin噪声 | 平滑连续 | 缺乏细节 | 地形高度图 |
| Voronoi图 | 多样性高 | 不够自然 | 房间分割 |
| 随机游走 | 简单高效 | 形态单一 | 走廊生成 |

### 7.2 路径生成算法对比

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 醉汉游走 | 简单高效 | 缺乏分支 | 线性关卡 |
| A*寻路 | 最优路径 | 计算复杂 | 智能连接 |
| Dijkstra | 全局最优 | 性能较差 | 多目标路径 |
| 随机生成树 | 保证连通 | 难以控制 | 迷宫生成 |

---

## 八、未来改进方向

### 8.1 算法优化
- [ ] 使用WFC算法生成微观细节
- [ ] 使用Voronoi图优化房间布局
- [ ] 使用A*算法优化走廊生成
- [ ] 使用Markov链生成房间序列

### 8.2 性能优化
- [ ] Job System并行化
- [ ] Burst Compiler加速
- [ ] GPU加速洞穴生成
- [ ] 增量式生成减少卡顿

### 8.3 功能扩展
- [ ] 支持3D洞穴生成
- [ ] 支持动态地形变化
- [ ] 支持多层关卡
- [ ] 支持自定义规则

---

**文档版本**: v1.0  
**最后更新**: 2026-01-17  
**维护者**: CRYPTA GEOMETRICA RE Team
